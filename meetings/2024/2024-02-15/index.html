<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=OPeqXG-QxW3ZD8BtmPikfA);.lst-kix_wz4k2emv5dd0-8>li:before{content:"\0025a0   "}ul.lst-kix_wz4k2emv5dd0-8{list-style-type:none}ul.lst-kix_wz4k2emv5dd0-5{list-style-type:none}ul.lst-kix_wz4k2emv5dd0-4{list-style-type:none}ul.lst-kix_wz4k2emv5dd0-7{list-style-type:none}ul.lst-kix_wz4k2emv5dd0-6{list-style-type:none}ul.lst-kix_wz4k2emv5dd0-1{list-style-type:none}ul.lst-kix_wz4k2emv5dd0-0{list-style-type:none}.lst-kix_ejekoet17s0c-3>li:before{content:"\0025cf   "}ul.lst-kix_wz4k2emv5dd0-3{list-style-type:none}ul.lst-kix_wz4k2emv5dd0-2{list-style-type:none}.lst-kix_ejekoet17s0c-4>li:before{content:"\0025cb   "}.lst-kix_ejekoet17s0c-5>li:before{content:"\0025a0   "}.lst-kix_ejekoet17s0c-2>li:before{content:"\0025a0   "}.lst-kix_ejekoet17s0c-6>li:before{content:"\0025cf   "}.lst-kix_wz4k2emv5dd0-0>li:before{content:"\0025cf   "}ul.lst-kix_ejekoet17s0c-2{list-style-type:none}.lst-kix_ejekoet17s0c-0>li:before{content:"\0025cf   "}.lst-kix_ejekoet17s0c-1>li:before{content:"\0025cb   "}ul.lst-kix_ejekoet17s0c-3{list-style-type:none}.lst-kix_ejekoet17s0c-8>li:before{content:"\0025a0   "}ul.lst-kix_ejekoet17s0c-0{list-style-type:none}ul.lst-kix_ejekoet17s0c-1{list-style-type:none}.lst-kix_wz4k2emv5dd0-2>li:before{content:"\0025a0   "}.lst-kix_ejekoet17s0c-7>li:before{content:"\0025cb   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_wz4k2emv5dd0-1>li:before{content:"\0025cb   "}.lst-kix_wz4k2emv5dd0-4>li:before{content:"\0025cb   "}ul.lst-kix_ejekoet17s0c-8{list-style-type:none}ul.lst-kix_ejekoet17s0c-6{list-style-type:none}ul.lst-kix_ejekoet17s0c-7{list-style-type:none}.lst-kix_wz4k2emv5dd0-3>li:before{content:"\0025cf   "}.lst-kix_wz4k2emv5dd0-7>li:before{content:"\0025cb   "}ul.lst-kix_ejekoet17s0c-4{list-style-type:none}ul.lst-kix_ejekoet17s0c-5{list-style-type:none}.lst-kix_wz4k2emv5dd0-6>li:before{content:"\0025cf   "}.lst-kix_wz4k2emv5dd0-5>li:before{content:"\0025a0   "}ol{margin:0;padding:0}table td,table th{padding:0}.c5{background-color:#ffffff;-webkit-text-decoration-skip:none;color:#1967d2;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-size:10pt;font-family:"Roboto"}.c9{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{-webkit-text-decoration-skip:none;color:#1967d2;font-weight:400;text-decoration:underline;text-decoration-skip-ink:none;font-size:9pt;font-family:"Roboto"}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c6{color:#000000;font-weight:400;text-decoration:none;font-size:20pt;font-family:"Arial"}.c10{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c13{background-color:#ffffff;max-width:600pt;}.c7{margin-left:36pt;padding-left:0pt}.c4{padding:0;margin:0}.c3{vertical-align:baseline;font-style:normal}.c8{color:inherit;text-decoration:inherit}.c12{margin-left:72pt;padding-left:0pt}.c11{height:11pt}.c14{background-color:#ffffff}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c13 doc-content"><p class="c0 c11"><span class="c1"></span></p><h1 class="c9" id="h.3cqww5fnhijq"><span class="c6 c3">Participants</span></h1><ul class="c4 lst-kix_wz4k2emv5dd0-0 start"><li class="c0 c7 li-bullet-0"><span class="c1">Yoav Weiss, Nic Jansma, Noam Helfman, Sia Karamalegos, Ian Clelland, Andy Lurhs, Andy Davies, Giacomo Zecchini, Dan Shappir, Michal Mocny, Sean Feng, Patrick Meenan, Carine Bournez, Jase Williams, Hugh Crail, Philip Tellis, Alex N Jose, Annie Sillivan, Noam Rosenthal, Hugh Crail</span></li></ul><h1 class="c9" id="h.jrids2cxi17n"><span class="c3 c6">Admin</span></h1><ul class="c4 lst-kix_ejekoet17s0c-0 start"><li class="c0 c7 li-bullet-0"><span class="c1">Call for Consensus - Splitting Long Animation Frames to a separate repo</span></li></ul><ul class="c4 lst-kix_ejekoet17s0c-1 start"><li class="c0 c12 li-bullet-0"><span class="c1">Deadline Feb 28th - please chime in on the mailing list</span></li></ul><ul class="c4 lst-kix_ejekoet17s0c-0"><li class="c0 c7 li-bullet-0"><span class="c1">Next call - February 29th</span></li></ul><h1 class="c9" id="h.hli7ex172jku"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https://docs.google.com/presentation/d/153KMPidMb6anjER5lQDBzvpirkE_nI5P8EQNCOErBgg/edit?resourcekey%3D0-X2nYQpUYIdIb9X4H-G-Kvg%23slide%3Did.p&amp;sa=D&amp;source=editors&amp;ust=1716319354513999&amp;usg=AOvVaw3o1LtcgxPP8_-Cw1g_vSX0">Element timing for containers</a></span><span class="c6 c3">&nbsp;- continued discussion</span></h1><p class="c0"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https://youtu.be/--BqFf6Zxg0&amp;sa=D&amp;source=editors&amp;ust=1716319354514275&amp;usg=AOvVaw3LaeCVzaPtRrxb40opJWEL">Recording</a></span></p><p class="c0"><span class="c1"><b>Jason</b>: Discussed this back in December</span></p><p class="c0"><span class="c1">.. Will recap the discussion, present the polyfill and continue discussion</span></p><p class="c0"><span class="c1">&hellip; Talked about how Element Timing only supports a small subset of elements</span></p><p class="c0"><span class="c1">&hellip; More of the web is component based, people want to know when a component or a subsection of the DOM was painted</span></p><p class="c0"><span class="c1">&hellip; Even composite elements have this problem and are not candidates for Element Timing</span></p><p class="c0"><span class="c1">&hellip; Extends into LCP. </span></p><p class="c0"><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 746.98px;<b> height</b>: 399.39px;"><img alt="" src="images/image1.png" style="width: 746.98px;<b> height</b>: 399.39px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c11"><span class="c1"></span></p><p class="c0"><span class="c1">&hellip; want to be able to measure components as well</span></p><p class="c0"><span class="c1">&hellip; Decided to try out what a user-land prototype may look like</span></p><p class="c0"><span>&hellip; </span><span class="c5"><a class="c8" href="https://www.google.com/url?q=https://jasonwilliams.github.io/container-timing/&amp;sa=D&amp;source=editors&amp;ust=1716319354514858&amp;usg=AOvVaw3JsCNvvHRsWx6yS7CIrF05">https://jasonwilliams.github.io/container-timing/</a></span></p><p class="c0"><span class="c1">&hellip; WIP polyfill</span></p><p class="c0"><span class="c1">&hellip; Will identify elementtiming attribute on elements, check which of them are &ldquo;container roots&rdquo;</span></p><p class="c0"><span class="c1">&hellip; Then it&rsquo;d attach elementtiming attributes on all of their children and wait for perfobserver</span></p><p class="c0"><span class="c1">&hellip; Replaces the prefobserver with this class TODO</span></p><p class="c0"><span class="c1">&hellip; Changes that happen inside the container fire a perf entry for the container</span></p><p class="c0"><span class="c1">&hellip; The entry interface is similar to a normal element timing (differences highlighted)</span></p><p class="c0"><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 707.76px;<b> height</b>: 372.54px;"><img alt="" src="images/image2.png" style="width: 707.76px;<b> height</b>: 372.54px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c11"><span class="c1"></span></p><p class="c0"><span class="c1">&hellip; startTime is the first paint event inside the container</span></p><p class="c0"><span class="c1">&hellip; renderTime is the latest paint event</span></p><p class="c0"><span class="c1">&hellip; lastElementSubElement - the last element</span></p><p class="c0"><span class="c1">&hellip; open question - should we include size? LCP does, but including this would require getBoundingClientRect, which will trigger style layout and slowness</span></p><p class="c0"><span class="c1">&hellip; In the table example, once the container is painted we get an entry, and on update we get another entry</span></p><p class="c0"><span class="c1">&hellip; startTime didn&rsquo;t change, the lastPaintedSubElement did</span></p><p class="c0"><span class="c1">&hellip; For a single paint, we probably have many sub elements that painted at the same time</span></p><p class="c0"><span class="c1">&hellip; Another example of adding a paragraph into the DOM</span></p><p class="c0"><span class="c1">&hellip; Works because the polyfill is using mutation observer and we add the elementtiming attribute to the new element immediately</span></p><p class="c0"><span class="c1">&hellip; So can attribute back the element when we get the performance entry</span></p><p class="c0"><span class="c1">&hellip; Shadow DOM &hellip;interesting. The polyfill doesn&rsquo;t work because we can&rsquo;t get events from inside the shadow root</span></p><p class="c0"><span class="c1">&hellip; Getting a single event for the inside of the shadow root, I guess it&rsquo;s treated as a single element</span></p><p class="c0"><span class="c1">&hellip; Finally SVG, similar to shadow DOM. No hooks to know when an SVG finished painting. Any solution here would need to be provided by the browser</span></p><p class="c0"><span class="c1">&hellip; we can argue if SVG is a single element or multiple element in cases of progressive rendering inside the SVG</span></p><p class="c0"><span class="c1">&hellip; Element Timing is binary. Container timing would emit entries multiple times, and would fire events after interaction, etc.</span></p><p class="c0"><span class="c1">&hellip; e.g. a carousel would trigger element for each image that was injected.</span></p><p class="c0"><span class="c1">&hellip; Not relevant if we&rsquo;re focused</span></p><p class="c0"><span class="c1">&hellip; TODO</span></p><p class="c0"><span class="c1">&hellip; Polyfill hasn&rsquo;t touched on animations at all, not sure if it can pick up on that (not sure of feasibility)</span></p><p class="c0"><span class="c1">&hellip; Showing the last sub-painted element, is that enough?</span></p><p class="c0"><span class="c1">&hellip; e.g. if element has content painted in it and container element that it fires, but only a small section painted, does the developer know how much is enough to say this container is ready?</span></p><p class="c0"><span class="c1"><b>Michal</b>: I wasn&rsquo;t sure, but was glad to see that MutaitonObservers are viable to inject elementTiming attribute for content about to be painted</span></p><p class="c0"><span class="c1"><b>Jase</b>: Happily surprised to see that work</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Would that be race-y?</span></p><p class="c0"><span class="c1">&hellip; I would expect because MO fire async</span></p><p class="c0"><span class="c1"><b>Michal</b>: Or are they aligned with animation frames?</span></p><p class="c0"><span class="c1">&hellip; I think text would be presented in the very next frame</span></p><p class="c0"><span class="c1">&hellip; Since it worked with text, I think it should work</span></p><p class="c0"><span class="c1"><b>Jase</b>: Is there a good way for testing this out, or a testing-bed where we can be absolutely certain</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Very slow machines, or introducing a delay explicitly</span></p><p class="c0"><span class="c1">&hellip; Observing code when MO fires or is dispatched</span></p><p class="c0"><span class="c1"><b>Michael</b>: Anyone know guaranteed timing of MO?</span></p><p class="c0"><span class="c1">&hellip; Or you can use UserTiming and see where it&rsquo;s shown related to rendering</span></p><p class="c0"><span class="c1"><b>Noam</b>: MO are batched into the same microtask and presented</span></p><p class="c0"><span class="c1">&hellip; Less eager than MutationEvents but more eager than rAF</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Mutation Events are going away</span></p><p class="c0"><span class="c1"><b>Michal</b>: Generally, super-thrilled you could put together a polyfill and demo. &nbsp;Type of feedback I&rsquo;d hope to see is what is polyfill-able and not?</span></p><p class="c0"><span class="c1">&hellip; Then see what are the value?</span></p><p class="c0"><span class="c1">&hellip; First question is it seems like you have to inject polyfill eagerly in initial content embedded into the page has to have elementTiming attribute in the page of HTML</span></p><p class="c0"><span class="c1">&hellip; Already a law of existing ElementTiming</span></p><p class="c0"><span class="c1">&hellip; Any library that tries to lazyLoad itself (or late) cannot sprinkle page with ElementTiming, if I understand correctly and this would apply here</span></p><p class="c0"><span class="c1"><b>Jase</b>: Yes you need to inject eagerly</span></p><p class="c0"><span class="c1">&hellip; polyfill starts marking markup right away</span></p><p class="c0"><span class="c1">&hellip; It looks like it&rsquo;s fine working before .observe() is called</span></p><p class="c0"><span class="c1">&hellip; Feels like as long as everything is in place before .observe() is OK, but not sure if anything earlier is needed</span></p><p class="c0"><span class="c1"><b>Yoav</b>: I suspect that is not necessarily true, with buffered:true</span></p><p class="c0"><span class="c1"><b>Michal</b>: But generally you have to have the elementTiming attribute before the first paint of a node</span></p><p class="c0"><span class="c1">&hellip; No way even to know if the thing you&rsquo;re applying the ET tag to won&rsquo;t paint due to X Y Z</span></p><p class="c0"><span class="c1">&hellip; From the server you&rsquo;d have to apply elementTiming tag to all children immediately</span></p><p class="c0"><span class="c1"><b>Jase</b>: In polyfill we&rsquo;re blocking in the head and injecting those</span></p><p class="c0"><span class="c1">&hellip; For regular ET you&rsquo;d have to have those annotated anyway</span></p><p class="c0"><span class="c1"><b>Michal</b>: If ET could be a bit more flexible here, polyfill could be loaded a bit lazier</span></p><p class="c0"><span class="c1"><b>Ian</b>: Wondering if there&rsquo;s any caveats with polyfill or in general on nested containers</span></p><p class="c0"><span class="c1">&hellip; Time container you&rsquo;re adding to another container you&rsquo;re timing, does it fire events on both (or should it?)</span></p><p class="c0"><span class="c1"><b>Jase</b>: I was thinking about this, I haven&rsquo;t taken nested containers into account. Polyfill works is if element has ET on it, it will search for nearest parent container</span></p><p class="c0"><span class="c1">&hellip; For instance if you had two containers, and inner had a paint event, the outer would not currently emit and entry, only the inner container</span></p><p class="c0"><span class="c1">&hellip; How would we expect it to behave?</span></p><p class="c0"><span class="c1">&hellip; Not too much work or discussion on how we want nested containers to work</span></p><p class="c0"><span class="c1"><b>Ian</b>: OK so still an open question</span></p><p class="c0"><span class="c1">&hellip; Imagine different authors on different parts of a site may want to use this</span></p><p class="c0"><span class="c1">&hellip; Another question, want to give developers an option for how much of a container was painted</span></p><p class="c0"><span class="c1">... Many containers expand to fill contents, so it&rsquo;s 100%</span></p><p class="c0"><span class="c1">&hellip; Working with something else or containers with fixed sizes?</span></p><p class="c0"><span class="c1"><b>Jase</b>: Containers can expand to fill whatever is injected, more on the fixed container side, text and an image</span></p><p class="c0"><span class="c1">&hellip; Fixed widget, whether image is there or not, it doesn&rsquo;t change size</span></p><p class="c0"><span class="c1">&hellip; If image takes up more size, do they want to know if image and the whole container loaded or just the text</span></p><p class="c0"><span class="c1">&hellip; Geared more towards fixed-sized widgets</span></p><p class="c0"><span class="c1">&hellip; Added a lastXelement so developers can check</span></p><p class="c0"><span class="c1"><b>Noam</b>: Regarding question from slide 14, it feels to me that the answer is &ldquo;Yes&rdquo;, we should allow developers some way to indicate whent hey&rsquo;re interested in getting events from the container</span></p><p class="c0"><span class="c1">&hellip; I can imagine when this is important, to stop and modify things or not get events</span></p><p class="c0"><span class="c1">&hellip; Not sure what form API should take</span></p><p class="c0"><span class="c1"><b>Michal</b>: observer.disconnect() exists</span></p><p class="c0"><span class="c1"><b>Noam</b>: Maybe a timeout on .observe() options</span></p><p class="c0"><span class="c1"><b>Yoav</b>: I think this is different from .disconnect()</span></p><p class="c0"><span class="c1"><b>Noam</b>: For a certain container, a dialog, maybe hidden</span></p><p class="c0"><span class="c1"><b>Yoav</b>: .disconnect() will disconnect observer but other observers will still get timing</span></p><p class="c0"><span class="c1">&hellip; You want to remove elementTiming attribute and have that stop emitting entries</span></p><p class="c0"><span class="c1"><b>Noam</b>: So top element container .removeAttribute() would recursively remove it from all child elements</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Or in polyfill it can remove all timings from all children and stop adding it to new additions</span></p><p class="c0"><span class="c1"><b>Noam</b>: Second question, have you spent time thinking about the performance impact of adding attributes and traversing elements</span></p><p class="c0"><span class="c1">&hellip; What could we expect to be the performance impact of such behavior?</span></p><p class="c0"><span class="c1"><b>Jase</b>: Examples you saw, I played around with having it on and off, but didn&rsquo;t feel like a real-world scenario</span></p><p class="c0"><span class="c1">&hellip; Follow-up for me</span></p><p class="c0"><span class="c1"><b>Yoav</b>: On easy way to test worst-case scenario of ElementTiming is to remove in Chromium the check that would report ET for everything, to see if that regresses something</span></p><p class="c0"><span class="c1">&hellip; At the very least I&rsquo;d add that behind a flag and flip it in a WPT and see it on a bunch of popular sites to see if there&rsquo;s any visible impact to this or not</span></p><p class="c0"><span class="c1">&hellip; Take it from there if the answer is &ldquo;Yes&rdquo;</span></p><p class="c0"><span class="c1">&hellip; Maybe a broader scale experiment could show</span></p><p class="c0"><span class="c1"><b>Noam</b>: Even if it doesn&rsquo;t show on local benchmark, likely to show on wider-scale higher-percentiles</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Regarding Shadow DOM, we have an open issue for the longest while</span></p><p class="c0"><span>&hellip; </span><span class="c5"><a class="c8" href="https://www.google.com/url?q=https://github.com/WICG/element-timing/issues/3&amp;sa=D&amp;source=editors&amp;ust=1716319354518997&amp;usg=AOvVaw0woCTruhPSzHgtgNDUkF1t">https://github.com/WICG/element-timing/issues/3</a></span></p><p class="c0"><span class="c1">&hellip; Discussed at TPAC</span></p><p class="c0"><span class="c1">&hellip; If ElementTiming would&rsquo;ve reported from inside open Shadow DOMs, would that have been enough for polyfill to take that into account</span></p><p class="c0"><span class="c1">&hellip; If we fix ElementTiming on that front, is it enough for polyfill to take over</span></p><p class="c0"><span class="c1"><b>Jase</b>: How do you envision ET added to the open Shadow DOM host, getting the event like everything else?</span></p><p class="c0"><span class="c1"><b>Yoav</b>: ET being added as part of the component, various parts in Shadow DOM, internal elements getting events fired</span></p><p class="c0"><span class="c1">&hellip; May be over-simplifying this</span></p><p class="c0"><span class="c1"><b>Jase</b>: Would allow PerformanceObserver outside to pick up on these events? &nbsp;Then the polyfill should work</span></p><p class="c0"><span class="c1"><b>Michal</b>: Does anyone have context for why ET is not supported in Shadow DOM?<br><b>Yoav</b>: For initial release of ET we didn&rsquo;t want to tackle complexity</span></p><p class="c0"><span class="c1">&hellip; Main reason was it was too complex</span></p><p class="c0"><span class="c1">&hellip; People moved on</span></p><p class="c0"><span class="c1">&hellip; I think if we concentrated effort on solving it, we could reach some consensus </span></p><p class="c0"><span>(TPAC discussion links </span><span class="c2"><a class="c8" href="https://www.google.com/url?q=https://docs.google.com/document/d/1RbszCu4NG-fcRRoL1TsP6SvjohIuz-uxv5NZm_6iA4U/edit%23heading%3Dh.3zh1jt8o97dg&amp;sa=D&amp;source=editors&amp;ust=1716319354519676&amp;usg=AOvVaw3N8TyQXI7OzrI4b3-RP1TN">https://docs.google.com/document/d/1RbszCu4NG-fcRRoL1TsP6SvjohIuz-uxv5NZm_6iA4U/edit#heading=h.3zh1jt8o97dg</a></span></p><p class="c0 c14"><span class="c2"><a class="c8" href="https://www.google.com/url?q=https://1drv.ms/p/s!AieUMe5bQRWh8qlurhV_ghxLZDor-A?e%3DElL16f&amp;sa=D&amp;source=editors&amp;ust=1716319354519889&amp;usg=AOvVaw1OmTMXHJaIoKCA0HiscdlK">https://1drv.ms/p/s!AieUMe5bQRWh8qlurhV_ghxLZDor-A?e=ElL16f</a></span></p><p class="c0 c14"><span class="c2"><a class="c8" href="https://www.google.com/url?q=https://youtu.be/sOaZsMFScE0&amp;sa=D&amp;source=editors&amp;ust=1716319354520056&amp;usg=AOvVaw02wbnm5ORoXxBStwaq-LOE">https://youtu.be/sOaZsMFScE0</a></span></p><p class="c0"><span>)</span></p><p class="c0"><span class="c1"><b>Sean</b>: element timing is not the only one have this restriction. i.e, selection API also have similar restriction</span></p><p class="c0"><span class="c1"><b>Michal</b>: Isolating Shadow DOM makes sense to me, just applying ET to the custom element, you may still be able to get a presentation time if we can nail the timing</span></p><p class="c0"><span class="c1">&hellip; A bunch of Shadow DOM things that you can observe with ET</span></p><p class="c0"><span class="c1"><b>Jase</b>: Elements in Shadow DOM should be implementation detail to anything inside</span></p><p class="c0"><span class="c1">&hellip; On one side, just a block, I care when that blocks was rendered</span></p><p class="c0"><span class="c1">&hellip; Some developers may think the block is doing complex stuff and want to know when those components are presented</span></p><p class="c0"><span class="c1"><b>Noam</b>: Could work if we passed PerformanceObserver to Shadow Root or something, ways to expose it</span></p><p class="c0"><span class="c1"><b>Yoav</b>: In the TPAC 2022 discussion, imposing opt-ins all the way down would be restrictive in terms of deployment</span></p><p class="c0"><span class="c1">&hellip; e.g. a lot of deployments of nested Shadow Roots</span></p><p class="c0"><span class="c1">&hellip; Forcing opt-in would be overly taxing</span></p><p class="c0"><span class="c1"><b>Michal</b>: Biggest question we have a wonderful slideshow of a whole page made up of tiny elements, LCP being a tiny corner textbox of one page</span></p><p class="c0"><span class="c1">&hellip; Now with container element in demo, the very first container element observer call represents the whole table</span></p><p class="c0"><span class="c1">&hellip; Same timing as final LCP value of this page (in example built)</span></p><p class="c0"><span class="c1">&hellip; Should the first paint of a container be what matters for LCP overall</span></p><p class="c0"><span class="c1">&hellip; More relevant for LCP element</span></p><p class="c0"><span class="c1">&hellip; Or do we want streams of paints within the container</span></p><p class="c0"><span class="c1">&hellip; Last one? &nbsp;Edit in a cell later on? &nbsp;How do you define the most contentful paint of a stream of paints?</span></p><p class="c0"><span class="c1"><b>Yoav</b>: What&rsquo;s a container in a context of LCP?</span></p><p class="c0"><span class="c1"><b>Michal</b>: This is a custom polyfill for a custom way to decorate?</span></p><p class="c0"><span class="c1">&hellip; Was thinking this could potentially apply to LCP algorithm?</span></p><p class="c0"><span class="c1">&hellip; This polyfill to understand if these conventions match user expectations, can they be applied to LCP algo</span></p><p class="c0"><span class="c1"><b>Yoav</b>: we&rsquo;d need to define an algorithm that magically finds containers</span></p><p class="c0"><span class="c1"><b>Jase</b>: I don&rsquo;t have a great answer to that</span></p><p class="c0"><span class="c1"><b>Michal</b>: Going forward, as we play with this polyfill and observe streams of paints for containers, would be interesting to do analysis, this % of the container was painted after an update</span></p><p class="c0"><span class="c1">&hellip; I could see the very first paint be a tiny portion, then a big update, then tiny updates, what should we go by? &nbsp;Middle one?</span></p><p class="c0"><span class="c1"><b>Jase</b>: How would you surface these updates? &nbsp;Similar to what we showed today with new entries?</span></p><p class="c0"><span class="c1">&hellip; When table was being painted they were in the same batch and render time</span></p><p class="c0"><span class="c1"><b>Michal</b>: You get a long list of ET when that happens? &nbsp;All size? Coordinates?</span></p><p class="c0"><span class="c1"><b>Jase</b>: I don&rsquo;t think there are coordinates in there?</span></p><p class="c0"><span class="c1"><b>Michal</b>: If you had an intersection rect you could look at the full size of this paint</span></p><p class="c0"><span class="c1"><b>Jase</b>: Theoretically yes. Take all of the paints in a batch and get the size for all of them, and report that</span></p><p class="c0"><span class="c1">&hellip; Close to what you&rsquo;re describing I think</span></p><p class="c0"><span class="c1">&hellip; Would the developer need to do any work around that, or a calculation of algorithm, make the choice to decide this was the most significant one</span></p><p class="c0"><span class="c1"><b>Michal</b>: With polyfill you could expose the data and leave up to the consumer to describe</span></p><p class="c0"><span class="c1">&hellip; As we watch a polyfill how it works, will the initiation match that a single largest paint be the most contentful</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Now that we have a polyfill, is anyone in the room planning to try to use that in some form?</span></p><p class="c0"><span class="c1">&hellip; Is it interesting enough for you to try to use, measure, see impact</span></p><p class="c0"><span class="c1"><b>Andy</b>: I was going to create some more examples that match our original presentation, examples of things that we see in the wild and how they match</span></p><p class="c0"><span class="c1"><b>Yoav</b>: What would it take for this polyfill to make its way into SpeedCurve&rsquo;s JavaScript</span></p><p class="c0"><span class="c1"><b>Andy</b>: Test on our own first, test in SC itself</span></p><p class="c0"><span class="c1"><b>Nic</b>: We&rsquo;d want to understand the performance implications. Companies that are using ET seem more suitable for using this</span></p><p class="c0"><span class="c1"><b>Andy</b>: The folks we got using ET are pretty knowledgeable</span></p><p class="c0"><span class="c1"><b>Jase</b>: Interested in trying this. The intersection rect idea seems interesting</span></p><p class="c0"><span class="c1">&hellip; Would be great to have others look at the performance aspects of it</span></p><p class="c0"><span class="c1"><b>Nic</b>: Thanks for the great demo and polyfill</span></p><p class="c0"><span class="c1"><b>Jase</b>: how do we proceed?</span></p><p class="c0"><span class="c1"><b>Yoav</b>: If you or other folks that have experimented with it come up with results to show to the group, can be an interesting follow-up</span></p><p class="c0"><span class="c1">&hellip; If any more gaps are found where this is insufficient, or ET needs to better e.g. handle Shadow DOM or needs to be lazier, that could be interesting conclusions to bring back to the group</span></p><p class="c0"><span class="c1">&hellip; Experimenting with polyfill, having conclusions and back to the group makes sense</span></p><p class="c0 c11"><span class="c1"></span></p></body></html><script>
const resize = (tagName) => {
  let elements = document.getElementsByTagName(tagName);
  for (let elem of elements) {
    elem.style.height = "";
    elem.style.width = "800px";
  }
};
window.addEventListener('load', () => {
  resize("img");
  resize("span");
});
</script>
