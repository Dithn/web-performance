<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_e6rz4bumhj9h-5{list-style-type:none}.lst-kix_e6rz4bumhj9h-7>li:before{content:"\0025cb   "}ul.lst-kix_e6rz4bumhj9h-6{list-style-type:none}.lst-kix_e6rz4bumhj9h-6>li:before{content:"\0025cf   "}ul.lst-kix_e6rz4bumhj9h-7{list-style-type:none}.lst-kix_e6rz4bumhj9h-8>li:before{content:"\0025a0   "}ul.lst-kix_e6rz4bumhj9h-8{list-style-type:none}ul.lst-kix_e6rz4bumhj9h-1{list-style-type:none}.lst-kix_e6rz4bumhj9h-5>li:before{content:"\0025a0   "}ul.lst-kix_e6rz4bumhj9h-2{list-style-type:none}ul.lst-kix_e6rz4bumhj9h-3{list-style-type:none}ul.lst-kix_e6rz4bumhj9h-4{list-style-type:none}.lst-kix_26to6tnv54w0-4>li:before{content:"\0025cb   "}.lst-kix_26to6tnv54w0-6>li:before{content:"\0025cf   "}.lst-kix_26to6tnv54w0-5>li:before{content:"\0025a0   "}.lst-kix_26to6tnv54w0-8>li:before{content:"\0025a0   "}ul.lst-kix_e6rz4bumhj9h-0{list-style-type:none}ul.lst-kix_26to6tnv54w0-2{list-style-type:none}ul.lst-kix_26to6tnv54w0-3{list-style-type:none}ul.lst-kix_26to6tnv54w0-0{list-style-type:none}.lst-kix_26to6tnv54w0-7>li:before{content:"\0025cb   "}ul.lst-kix_26to6tnv54w0-1{list-style-type:none}ul.lst-kix_26to6tnv54w0-6{list-style-type:none}ul.lst-kix_26to6tnv54w0-7{list-style-type:none}ul.lst-kix_26to6tnv54w0-4{list-style-type:none}ul.lst-kix_26to6tnv54w0-5{list-style-type:none}ul.lst-kix_26to6tnv54w0-8{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_26to6tnv54w0-3>li:before{content:"\0025cf   "}.lst-kix_e6rz4bumhj9h-0>li:before{content:"\0025cf   "}.lst-kix_e6rz4bumhj9h-1>li:before{content:"\0025cb   "}.lst-kix_26to6tnv54w0-2>li:before{content:"\0025a0   "}.lst-kix_26to6tnv54w0-1>li:before{content:"\0025cb   "}.lst-kix_e6rz4bumhj9h-3>li:before{content:"\0025cf   "}.lst-kix_26to6tnv54w0-0>li:before{content:"\0025cf   "}.lst-kix_e6rz4bumhj9h-2>li:before{content:"\0025a0   "}.lst-kix_e6rz4bumhj9h-4>li:before{content:"\0025cb   "}ol{margin:0;padding:0}table td,table th{padding:0}.c2{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c7{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c4{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c10{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c5{background-color:#ffffff;max-width:600pt;}.c8{color:inherit;text-decoration:inherit}.c6{padding:0;margin:0}.c3{margin-left:36pt;padding-left:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c5 doc-content"><h2 class="c4" id="h.gv31tuf7624j"><span class="c9">Participants</span></h2><p class="c0"><span class="c1">Rafael Lebre, Sean Feng, Pat Meenan, Nic Jansma, Yoav Weiss, Hao Liu, Ian Clelland, Aoyuan Zuo, Abhishek Ghosh, Benjamin De Kosnik, Michal Mocny, Mike Henniger, Giacomo Zecchini, Barry Pollard</span></p><h2 class="c4" id="h.ore9sqdbsvqj"><span class="c9">Admin</span></h2><ul class="c6 lst-kix_e6rz4bumhj9h-0 start"><li class="c0 c3 li-bullet-0"><span class="c1">Next call - May 23rd</span></li><li class="c0 c3 li-bullet-0"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https://github.com/httpwg/http-extensions/issues/2770&amp;sa=D&amp;source=editors&amp;ust=1716320368797559&amp;usg=AOvVaw0czNy0uddGd0lLnaQMWQXA">Compression Dictionaries stream format</a></span></li><li class="c0 c3 li-bullet-0"><span class="c1"><b>Pat</b>: Dictionary hash would be embedded in the response stream with a header that includes the dictionary</span></li><li class="c0 c3 li-bullet-0"><span class="c1">&hellip; Compression windows for zstd will be 5x the dict size</span></li><li class="c0 c3 li-bullet-0"><span class="c1">&hellip; link rel compression dictionary</span></li><li class="c0 c3 li-bullet-0"><span class="c1">&hellip; base64 encoded of the hash will require some processing &nbsp;to convert to a file</span></li><li class="c0 c3 li-bullet-0"><span class="c1">&hellip; Discussion to restrict to a single compression algorithm, but there&rsquo;s discussion on whether browsers would have to support both</span></li><li class="c0 c3 li-bullet-0"><span><b>Nic</b>: provided a list of all the issues. Folks with opinions should voice them</span></li></ul><h2 class="c4" id="h.pj78pijut743"><span class="c9">Minutes</span></h2><h3 class="c7" id="h.x10kbsve3ez5"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https://docs.google.com/presentation/d/1emHt3gnj-cjWXhQHEKIzm6smfL-uhIeS0AIgBSheW2U/edit?usp%3Dsharing&amp;sa=D&amp;source=editors&amp;ust=1716320368798835&amp;usg=AOvVaw1NpAf4Rai8Di8084ESo5P7">Dealing with entry updates over time</a></span><span class="c2">&nbsp;- Michal</span></h3><p class="c0"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https://youtu.be/jLAHP_Nr-aA&amp;sa=D&amp;source=editors&amp;ust=1716320368799215&amp;usg=AOvVaw2xNWG4UMpdcRvDyexHONEn">Recording</a></span></p><p class="c0"><span class="c1"><b>Michal</b>: 2 different groups came up with the same problem at the same time - performance entry measurement over time</span></p><p class="c0"><span class="c1">&hellip; Performance measurement takes time but any one complete performance entry is expected to be complete</span></p><p class="c0"><span class="c1">&hellip;<b> causes issues</b>: buffering, reporting delays or measurement complexity, tradeoffs on which data is reported</span></p><p class="c0"><span class="c1">&hellip; with event timing, the first thing we know is the start time timestamp, then processing start, after a hit test we have a target, and after all JS ran (including event listeners) we mark the processingEnd.</span></p><p class="c0"><span class="c1">&hellip; Then we wait for next paint for the duration</span></p><p class="c0"><span class="c1">&hellip; In chromium we try to assign an interaction ID, and you&rsquo;re not sure until other events happen (e.g. touch down has to wait for touch up)</span></p><p class="c0"><span class="c1">&hellip; Then the observer may get delayed further when reporting</span></p><p class="c0"><span class="c1">&hellip; What happens if the document was modified - the event target may no longer be there, and we lose our ability to observer that target because we delayed things</span></p><p class="c0"><span class="c1">&hellip; Another problem - the document may get unloaded before any of these things is observed</span></p><p class="c0"><span class="c1">&hellip; Example - event timing waiting on data</span></p><p class="c0"><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 653.29px;<b> height</b>: 323.46px;"><img alt="" src="images/image1.png" style="width: 653.29px;<b> height</b>: 323.46px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">&hellip; what happens when some things need to wait and others don&rsquo;t? Should we buffer everything in order to have a consistent timeline? Or emit the data we have when we have it?</span></p><p class="c0"><span class="c1">&hellip; Sometimes those time delays can be substantial</span></p><p class="c0"><span class="c1">&hellip; With LoAF, we can get entries before the relevant event timing entries have fired</span></p><p class="c0"><span class="c1">&hellip; so you may want to buffer, but that has tradeoffs</span></p><p class="c0"><span class="c1">&hellip; Navigation timing has that issue for a while. Might be complete after onload, but you have to poll the entry to see if all of its entries are there</span></p><p class="c0"><span class="c1">&hellip; For resource timing, the entries are fired only after fetch is completed</span></p><p class="c0"><span class="c1">&hellip; We want to wait longer - e.g. processing time</span></p><p class="c0"><span class="c1">&hellip; At the same time we want to know when a fetch was started - so want these entries sooner</span></p><p class="c0"><span class="c1">&hellip; For Paint and Element Timing - we may want more paints than just the first paint, but not necessarily to wait on them</span></p><p class="c0"><span class="c1">&hellip; We wanted an &ldquo;isFinal&rdquo; bool on LCP, but can&rsquo;t know that until after its emitted</span></p><p class="c0"><span class="c1">&hellip; So, what do we want?</span></p><p class="c0"><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 670.00px;<b> height</b>: 329.00px;"><img alt="" src="images/image3.png" style="width: 670.00px;<b> height</b>: 329.00px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span>&hellip; </span><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 666.00px;<b> height</b>: 327.00px;"><img alt="" src="images/image2.png" style="width: 666.00px;<b> height</b>: 327.00px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1"><b>Nic</b>: Are there stats on people using perf observer?</span></p><p class="c0"><span class="c1">&hellip; For resource timing it&rsquo;s easier for us to getEntriesByType</span></p><p class="c0"><span class="c1"><b>Michal</b>: A few entry types only have observable support. Anything with data coming in over time</span></p><p class="c0"><span class="c1">&hellip; personally interested in the observer version of it</span></p><p class="c0"><span class="c1"><b>Nic</b>: From our experience there are ergonomic reasons to use both</span></p><p class="c0"><span class="c1"><b>Barry</b>: I wonder why we&rsquo;re not looking at the last 200 entries rather than the first 200 entries. Personally, wished we supported both</span></p><p class="c0"><span class="c1"><b>Michal</b>: You&rsquo;d still have to do a bunch of polling, so you&rsquo;d never know when new entries show up. A sliding window can help, but you&rsquo;d still have to process the full list to do grouping, etc.</span></p><p class="c0"><span class="c1">&hellip; Also for buffering, any new observer added to the page may care more about the first 200 rather than the last 200. So may need a fixed window upfront and a sliding window at the end</span></p><p class="c0"><span class="c1"><b>Nic</b>: Is the goal here to find guidance for us for future specs?</span></p><p class="c0"><span class="c1"><b>Michal</b>: For me, there&rsquo;s a problem with EventTiming being hard, especially with LoAF</span></p><p class="c0"><span class="c1">&hellip; Preference for option 1, but it&rsquo;s complicated, even with the perf timeline doing default buffering</span></p><p class="c0"><span class="c1">&hellip; We&rsquo;re duplicating effort and need to offload it to the platform </span></p><p class="c0"><span class="c1">&hellip; At the same time, </span></p><p class="c0"><span class="c1"><b>Yoav</b>: Backward compat concerns are fine as long as we go with an opt-in</span></p><p class="c0"><span class="c1">... We can easily do that with Observer option</span></p><p class="c0"><span class="c1">... I don&#39;t think it should be a significant consideration</span></p><p class="c0"><span class="c1">... Main bit I&#39;m personally missing is I haven&#39;t tried to actually write observer code with each one of these options that would take into account lagging information</span></p><p class="c0"><span class="c1">... If I&#39;m reporting a certain perf entry that doesn&#39;t have all of its values, do I delay it, report it later</span></p><p class="c0"><span class="c1">... If I choose one option or the other, how does that affect things?</span></p><p class="c0"><span class="c1">... It might be interesting to play around with code examples for what these things may look like in real life</span></p><p class="c0"><span class="c1">... Interesting for RUM folks to do that</span></p><p class="c0"><span class="c1">... Wondering if Nic would be interested in playing around with</span></p><p class="c0"><span class="c1">... Joint exploration to see which pattern actually works in practice</span></p><p class="c0"><span class="c1">... Current status-quo works, but adds delays</span></p><p class="c0"><span class="c1">... Element ID is a perfect example, and something we also have for LCP</span></p><p class="c0"><span class="c1"><b>Michal</b>: Just those things we&#39;re aware of</span></p><p class="c0"><span class="c1">... As soon as that callback is fired, if you&#39;re trying to do any cross-checking</span></p><p class="c0"><span class="c1">... Let&#39;s say you&#39;re in a SPA you&#39;re in a different state of the world</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Anything like userland CLS attribution, what elements around this element, but by the time anyone is looking at this, they could be gone</span></p><p class="c0"><span class="c1"><b>Michal</b>: Two problems: eagerness vs. lazy</span></p><p class="c0"><span class="c1">... Lazier you are, riskier things get</span></p><p class="c0"><span class="c1">... Second problem is around grouping different entries by time</span></p><p class="c0"><span class="c1">... Maybe Performance Timeline needs a feature for that API</span></p><p class="c0"><span class="c1">... Maybe ask for a time-range I&#39;m interested in, an PO could have a start/end time</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Browser buffers all the things...</span></p><p class="c0"><span class="c1"><b>Michal</b>: It already is, knows its&#39; in the middle of buffering, website doesn&#39;t know that</span></p><p class="c0"><span class="c1">... Website author doesn&#39;t know new entry might just arrive</span></p><p class="c0"><span class="c1">... EventTiming is canonical example</span></p><p class="c0"><span class="c1"><b>Nic</b>: And ResourcTiming observing outstanding entries</span></p><p class="c0"><span class="c1"><b>Yoav</b>: For ResourceTmiing pending entries, you could ask to get all RT entries happening right now, even ones not emitted</span></p><p class="c0"><span class="c1">... Interesting way of looking at this</span></p><p class="c0"><span class="c1">... Concerned around complexity on developer side</span></p><p class="c0"><span class="c1">... How do they know what information is there, and what&#39;s available later</span></p><p class="c0"><span class="c1"><b>Michal</b>: Rough goal is to continue measuring and updating values to the latest, until we can no longer do that. &nbsp;That&#39;s when we flush whatever we have</span></p><p class="c0"><span class="c1">... All outstanding requests, now get resolved and we measure</span></p><p class="c0"><span class="c1">... At least we know what we&#39;re waiting for</span></p><p class="c0"><span class="c1"><b>Nic</b>: if we have all these observers outstanding and unload fires, I&rsquo;ll grab all the data I have and send it</span></p><p class="c0"><span class="c1"><b>Michal</b>: Before any page lifecycle even begins to fire, we&rsquo;d flush anything. We&rsquo;re already doing this kind of buffering</span></p><p class="c0"><span class="c1">&hellip; So the question is should we report what we have earlier?</span></p><p class="c0"><span class="c1">&hellip; Currently we&rsquo;re being maximally lazy</span></p><p class="c0"><span class="c1">&hellip; today we don&rsquo;t know if we&rsquo;re seeing all the data or some of the data</span></p><p class="c0"><span class="c1">&hellip; Regarding an opt-in - We&rsquo;d need to support both variants forever </span></p><p class="c0"><span class="c1"><b>Yoav</b>: Agree an opt-in means that old behavior remains valid and useful</span></p><p class="c0"><span class="c1">... Adds complexity on browser implementation side</span></p><p class="c0"><span class="c1">... Unless it can be abstracted away</span></p><p class="c0"><span class="c1"><b>Michal</b>: You can always fallback to &quot;Option 1&quot; by Observer await all of the lazy values</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Are promises for missing values useful? &nbsp;Detect, in code, that those are promises</span></p><p class="c0"><span class="c1">... Don&#39;t want RUM code to know which bit of information is always available vs. sometimes available</span></p><p class="c0"><span class="c1">... Some way to detect that, value currently holding is complete or not</span></p><p class="c0"><span class="c1"><b>Nic</b>: So to bring it back to all the proposal, you mentioned a few scenarios that would need that</span></p><p class="c0"><span class="c1">&hellip; We could take those use cases and different options</span></p><p class="c0"><span class="c1">&hellip; pseudocode can help us understand things</span></p><p class="c0"><span class="c1"><b>Michal</b>: Would be great if webvitals.js could also explore that</span></p><p class="c0"><span class="c1"><b>Barry</b>: Definitely things were more painful due to buffering, resulting in out of order entries</span></p><p class="c0"><span class="c1"><b>Michal</b>: Option 1 leans more into these problems</span></p><p class="c0"><span class="c1">&hellip; Being less lazy can improve things</span></p><p class="c0"><span class="c1"><b>Nic</b>: For tracking, can you file a performance timeline issue linking to the slides, so we&rsquo;d be able to track this work and move this forward</span></p><p class="c0"><span class="c1"><b>Michal</b>: *thumbs up*</span></p><h3 class="c7" id="h.eeqwnrd0zlw9"><span class="c10"><a class="c8" href="https://www.google.com/url?q=https://github.com/w3c/resource-timing/issues/303&amp;sa=D&amp;source=editors&amp;ust=1716320368807625&amp;usg=AOvVaw1y_ey5kh2vVBtGTzZxnP_g">Reflect preload information (in ResourceTiming?) (RT#303)</a></span></h3><p class="c0"><span class="c1"><b>Nic</b>: wanted to revive this issue as it hasn&rsquo;t moved since 2022. If a preload is initiated, e.g. with Early Hints</span></p><p class="c0"><span class="c1">&hellip; we want to know if the resource is actually used by the page, or if the resources are somehow wasted as they were never used</span></p><p class="c0"><span class="c1">&hellip; You get all the resources that are fetched in resource timing, but no indication if they were used</span></p><p class="c0"><span class="c1">&hellip; Couple of different proposals on the issue</span></p><p class="c0"><span class="c1">&hellip; One option is to have a second entry when a preloaded resource is actually consumed</span></p><p class="c0"><span class="c1">&hellip; Current observers would get more entries that they expect</span></p><p class="c0"><span class="c1">&hellip; Another option is another timestamp on the existing entry, which is updated once the resource is actually consumed, if that happens</span></p><p class="c0"><span class="c1">&hellip; Relevant to previous discussion regarding late update of entries</span></p><p class="c0"><span class="c1">&hellip; Any other folks that want this data? Akamai are interested in this</span></p><p class="c0"><span class="c1">&hellip; You can get this information in devtools, but no other indicator</span></p><p class="c0"><span class="c1">&hellip; e.g. in Chrome you can see it, but not in reporting API nor resource timing</span></p><p class="c0"><span class="c1">&hellip; Thoughts on the easiest way to consume this info (beyond the previous discussion)</span></p><p class="c0"><span class="c1">&hellip; Personally prefer the second proposal - timestamp that gets updated later</span></p><p class="c0"><span class="c1">&hellip; The first can cause us to create additional entries</span></p><p class="c0"><span class="c1">&nbsp;<b>Yoav</b>: Super interested in this problem, I keep seeing many times opening Dev Tools on websites, there&#39;s a pile-up of resources-that-were-preloaded-but-not-used console warnings</span></p><p class="c0"><span class="c1">... Websites may not have this problem if they knew this was happening at scale</span></p><p class="c0"><span class="c1">... Seems like a problem we need to solve</span></p><p class="c0"><span class="c1">... Between the two options, I&#39;d prefer (2) an additional property that updates over time</span></p><p class="c0"><span class="c1">... Even more if we solve this in a well-paved-path solution to updating Performance Entries after-the-fact</span></p><p class="c0"><span class="c1">... This would be a natural candidate for that. &nbsp;I don&#39;t think there are any tradeoffs</span></p><p class="c0"><span class="c1">... Third option: Reporting API that we could use here. &nbsp;Here&#39;s a list of resource URLs that were never used.</span></p><p class="c0"><span class="c1">... You get RT on one hand, and a pile of Resources that weren&#39;t used for this particular session</span></p><p class="c0"><span class="c1">... Like mentioned in the past there&#39;s a problem coordinating one with the other</span></p><p class="c0"><span class="c1"><b>Nic</b>: One could use Reporting Observer in-page to grab that data</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Yes you could combine that data with what you have in the page</span></p><p class="c0"><span class="c1"><b>Ian</b>: Resource would have to be sent at the end of the page right?</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Console warnings in Chrome, also in Webkit (possibly) effectively a timeout after onload</span></p><p class="c0"><span class="c1">... We don&#39;t really know these resources are never consumed</span></p><p class="c0"><span class="c1">... But if they were preloaded early on and not used until a good chunk after onload has passed, presuming they&#39;re not going to be used</span></p><p class="c0"><span class="c1">... Because this would web-expose information, maybe need better heuristics for this</span></p><p class="c0"><span class="c1">... But it could be a heuristic approach</span></p><p class="c0"><span class="c1">... e.g. &quot;this&quot; is likely unused</span></p><p class="c0"><span class="c1">... We could also send a Reporting API report after render dies, with more concrete info</span></p><p class="c0"><span class="c1"><b>Barry</b>: I like doing it at the end of the page, I find simple bugs with DevTool implementation.</span></p><p class="c0"><span class="c1">... e.g. after timeout, or with low priority that&#39;s not blocking anything</span></p><p class="c0"><span class="c1">... loads of things that heuristic isn&#39;t perfect</span></p><p class="c0"><span class="c1">... Where at the end of the page you can more definitively know</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Tradeoff is at the end of the page hard to correlate with a specific session</span></p><p class="c0"><span class="c1">... Question in a previous meeting, right now Reports are credential-less</span></p><p class="c0"><span class="c1">... Is there a specific reason why that is</span></p><p class="c0"><span class="c1">... Having credentials on reports could help w/ correlation after the fact</span></p><p class="c0"><span class="c1"><b>Barry</b>: Doesn&#39;t have to be with Reporting API, could be option 2 here</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Option 2 could be after renderer dies</span></p><p class="c0"><span class="c1">... onvisibilitychange do that kind of check</span></p><p class="c0"><span class="c1"><b>Ian</b>: Credentials question was around privacy and cross-site tracking</span></p><p class="c0"><span class="c1">... We do send credentials if same-site-origin</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Just cross-origin we omit credentials</span></p><p class="c0"><span class="c1"><b>Nic</b>: There&rsquo;s some page-specific info that&rsquo;s lost with the reporting API</span></p><p class="c0"><span class="c1">&hellip; that&rsquo;s why in-page is more powerful</span></p><p class="c0"><span class="c1"><b>Yoav</b>: Reporting observer of give me all the unused preloads &quot;so far&quot;, could kick off from visibilitychange</span></p><p class="c0"><span class="c1">... Do correlation at that point</span></p><p class="c0"><span class="c1"><b>Nic</b>: If we have the preloadConsumed attribute being zero that would give you the same information</span></p><p class="c0"><span class="c1"><b>Abishek</b>: *commenting in chat*<br>&hellip; Is it possible to look at a ResourceTiming entry and understand if the request was a preload? </span></p><p class="c0"><span class="c1">&hellip; Maybe something like the initiatorType ? Combined with the param like preloadConsume and its existence/timestamp it might give website owners more control to identify all the resources preloaded and define more flexible thresholds to measure wastefulness (if it did not happen by X event, may not be just end of page load)?</span></p><p class="c0"><span class="c1"><b>Nic</b>: there&rsquo;s an initiatorType for preload</span></p><p class="c0"><span class="c1">&hellip; So developers can apply their own thresholds</span></p><p class="c0"><span class="c1"><b>Barry</b>: When a resource is used from the memory cache, that doesn&rsquo;t create a second entry</span></p><p class="c0"><span class="c1">&hellip; Abishek&rsquo;s proposal here would not work due to the missing subsequent requests</span></p><p class="c0"><span class="c1"><b>Nic</b>: Thanks! I&rsquo;ll try to summarize this in the ticket</span></p><p class="c0"><span><b>Yoav</b>: One option is to wait for delayed attributes to be a thing (previous discussion), other option is to move forward with some sort of Reporting API </span></p></body></html><script>
const resize = (tagName) => {
  let elements = document.getElementsByTagName(tagName);
  for (let elem of elements) {
    elem.style.height = "";
    elem.style.width = "800px";
  }
};
window.addEventListener('load', () => {
  resize("img");
  resize("span");
});
</script>
