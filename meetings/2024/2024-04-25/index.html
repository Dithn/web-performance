<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_thv2v0h8n4f7-0>li:before{content:"\0025cf   "}.lst-kix_thv2v0h8n4f7-1>li:before{content:"\0025cb   "}.lst-kix_thv2v0h8n4f7-2>li:before{content:"\0025a0   "}.lst-kix_thv2v0h8n4f7-5>li:before{content:"\0025a0   "}.lst-kix_bnzzrq9sfpde-0>li:before{content:"\0025cf   "}.lst-kix_thv2v0h8n4f7-3>li:before{content:"\0025cf   "}.lst-kix_thv2v0h8n4f7-7>li:before{content:"\0025cb   "}.lst-kix_bnzzrq9sfpde-1>li:before{content:"\0025cb   "}.lst-kix_thv2v0h8n4f7-4>li:before{content:"\0025cb   "}.lst-kix_thv2v0h8n4f7-8>li:before{content:"\0025a0   "}.lst-kix_bnzzrq9sfpde-3>li:before{content:"\0025cf   "}.lst-kix_bnzzrq9sfpde-2>li:before{content:"\0025a0   "}.lst-kix_bnzzrq9sfpde-4>li:before{content:"\0025cb   "}.lst-kix_thv2v0h8n4f7-6>li:before{content:"\0025cf   "}.lst-kix_bnzzrq9sfpde-7>li:before{content:"\0025cb   "}.lst-kix_bnzzrq9sfpde-6>li:before{content:"\0025cf   "}.lst-kix_bnzzrq9sfpde-8>li:before{content:"\0025a0   "}.lst-kix_bnzzrq9sfpde-5>li:before{content:"\0025a0   "}ul.lst-kix_bnzzrq9sfpde-3{list-style-type:none}ul.lst-kix_bnzzrq9sfpde-4{list-style-type:none}ul.lst-kix_bnzzrq9sfpde-1{list-style-type:none}ul.lst-kix_bnzzrq9sfpde-2{list-style-type:none}ul.lst-kix_bnzzrq9sfpde-7{list-style-type:none}ul.lst-kix_bnzzrq9sfpde-8{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ul.lst-kix_bnzzrq9sfpde-5{list-style-type:none}ul.lst-kix_bnzzrq9sfpde-6{list-style-type:none}ul.lst-kix_bnzzrq9sfpde-0{list-style-type:none}ul.lst-kix_thv2v0h8n4f7-8{list-style-type:none}ul.lst-kix_thv2v0h8n4f7-6{list-style-type:none}ul.lst-kix_thv2v0h8n4f7-7{list-style-type:none}ul.lst-kix_thv2v0h8n4f7-4{list-style-type:none}ul.lst-kix_thv2v0h8n4f7-5{list-style-type:none}ul.lst-kix_thv2v0h8n4f7-2{list-style-type:none}ul.lst-kix_thv2v0h8n4f7-3{list-style-type:none}ul.lst-kix_thv2v0h8n4f7-0{list-style-type:none}ul.lst-kix_thv2v0h8n4f7-1{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c11{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c7{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c10{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c3{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c6{background-color:#ffffff;max-width:600pt;}.c8{margin-left:72pt;padding-left:0pt}.c2{margin-left:36pt;padding-left:0pt}.c5{color:inherit;text-decoration:inherit}.c9{padding:0;margin:0}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c6 doc-content"><h2 class="c10" id="h.ms9ltxwq788i"><span class="c4">Participants</span></h2><p class="c1"><span class="c0">Dan Shappir, Katie Syler-Miller, Fergal Daly, Nic Jansma, Pat Meenan, Noam Rosenthal, Dave Hunt, Ming Ying Chung, Aoyuan Zuo, Ian Clelland, Barry Pollard, Michal Mocny, Carine Bournez, Timo Ijhof, Benjamin De Kosnik, Mike Jackson, Noam Helfman, Yoav Weiss, Alex N Jose, Tariq Rafique, Amiya Gupta, Mike Henniger</span></p><h2 class="c10" id="h.swb35gflxw63"><span class="c4">Admin</span></h2><ul class="c9 lst-kix_thv2v0h8n4f7-0 start"><li class="c1 c2 li-bullet-0"><span class="c0">Next call - May 9th</span></li><li class="c1 c2 li-bullet-0"><span class="c3"><a class="c5" href="https://www.google.com/url?q=https://lists.w3.org/Archives/Public/public-web-perf/2024Apr/0001.html&amp;sa=D&amp;source=editors&amp;ust=1716320059375480&amp;usg=AOvVaw0SPzunhfW9zsVRqpOFbXG3">Compression Dictionaries open questions</a></span></li></ul><ul class="c9 lst-kix_thv2v0h8n4f7-1 start"><li class="c1 c8 li-bullet-0"><span>Please review the issues and post comments. In 2 weeks we may have follow up discussions</span></li></ul><h2 class="c10" id="h.vq0yywl8716p"><span class="c4">Minutes</span></h2><h3 class="c11" id="h.ruddjzqu081c"><span class="c3"><a class="c5" href="https://www.google.com/url?q=https://github.com/WICG/pending-beacon/issues/87&amp;sa=D&amp;source=editors&amp;ust=1716320059376331&amp;usg=AOvVaw358Ajokkz9lqZvPk6-5bsX">fetchLater RequestLimit</a></span></h3><p class="c1"><span class="c3"><a class="c5" href="https://www.google.com/url?q=https://youtu.be/NjIlJdeMZ5k&amp;sa=D&amp;source=editors&amp;ust=1716320059376895&amp;usg=AOvVaw07UV3nf2vgZwCjLXTgf36N">Recording</a></span></p><p class="c1"><span class="c0"><b>NoamR</b>: fetchLater is the new pending beacon, slightly lower level.</span></p><p class="c1"><span class="c0">.. A drop in replacement for fetch() that waits until the page is destroyed or invisible for a long time</span></p><p class="c1"><span class="c0">&hellip; Allows creating something like PendingBeacon in user land</span></p><p class="c1"><span class="c0">&hellip; The API uses bandwidth after the page is loaded, by design. Other fetches are canceled at the point</span></p><p class="c1"><span class="c0">&hellip; This creates a situation where closing the tab could trigger many MBs of data to be sent, if this would unlimited, and the user would have no recourse (closing the tab doesn&rsquo;t help)</span></p><p class="c1"><span class="c0">&hellip; So we need to limit the amount of bandwidth in the context of a top-lvel window, as that&rsquo;s where users have control</span></p><p class="c1"><span class="c0">&hellip; Decided on 640KB as a number that&rsquo;s shared between same origin iframes.</span></p><p class="c1"><span class="c0">&hellip; The other side is that we don&rsquo;t want a single provider takes up the whole quota, preventing other scripts from getting any quota</span></p><p class="c1"><span class="c0">&hellip; So we decided on 64KB limit per reporting origin</span></p><p class="c1"><span class="c0">&hellip; Also, for cross-origin iframes that are allowed to use the quota, they&rsquo;d also get 64K, as if they were another reporting origin</span></p><p class="c1"><span class="c0">&hellip; This is where the discussion is atm</span></p><p class="c1"><span class="c0"><b>Timo</b>: does that mean that for a site, its limit would be different if it&rsquo;s iframed?</span></p><p class="c1"><span class="c0"><b>NoamR</b>: Yes, for cross origin iframes. And they&rsquo;d share the limit across that origin.</span></p><p class="c1"><span class="c0"><b>Dan</b>: We&rsquo;re talking about upstream data?</span></p><p class="c1"><span class="c0"><b>NoamR</b>: Yeah, request data</span></p><p class="c1"><span class="c0"><b>Dan</b>: Also 64K should be enough for anyone</span></p><p class="c1"><span class="c0"><b>NoamH</b>: Is there a reason why we shouldn&rsquo;t give a 64K quota to anyone and that&rsquo;s it?</span></p><p class="c1"><span class="c0"><b>NoamR</b>: If you had unlimited amount of data sent, the user would not have control</span></p><p class="c1"><span class="c0"><b>NoamH</b>: Why not a smaller quota per frame?</span></p><p class="c1"><span class="c0"><b>NoamR</b>: 640K seemed reasonable for the whole tab. 64K would be too low. You have your RUM provider, 1P, image CDN, etc</span></p><p class="c1"><span class="c0"><b>NoamH</b>: So 10 of those, but not for each cross-origin frame</span></p><p class="c1"><span class="c0"><b>NoamR</b>: Wanted to keep it simple, so have 64K per iframe to reduce complexity. We could also add more complexity in the future if needed.</span></p><p class="c1"><span class="c0"><b>Katie</b>: So if a site is setting their own beacons and have dozens of iframes, there&rsquo;s no quota on sending data sync. Afraid that a small quota would discourage 3Ps from switching to this mechanism, despite it being better for users</span></p><p class="c1"><span class="c0"><b>NoamR</b>: It&rsquo;s guaranteed(ish) to go through, so a tradeoff</span></p><p class="c1"><span class="c0"><b>Michal</b>: An alternative - a global limit incentivizes to stuff the pipe, hence the reporting origin limit. What if we allowed anyone to attach any beacon and then prioritize the smaller ones</span></p><p class="c1"><span class="c0"><b>NoamR</b>: That would go against the guarantees of the API. Add a lot of uncertainty. When fetchLater fails it fails fast, so you know immediately that you need to use an alternative mechanism</span></p><p class="c1"><span class="c0"><b>Nic</b>: From the perspective of a RUM provider, one concern was that the limit would incentivize folks to register early, with a dummy payload, etc. and we don&rsquo;t want folks to do that.</span></p><p class="c1"><span class="c0">&hellip; Data grows over time, and at some point that growth may trip over the quota. What should we do then?</span></p><p class="c1"><span class="c0">&hellip; Trying to think through the edge cases. It&rsquo;d be a bit complex</span></p><p class="c1"><span class="c0">&hellip; That seems like one of the consequences from protecting against lots of data being queued up</span></p><p class="c1"><span class="c0"><b>Timo</b>: Try to incentivize folks to use the API, which means it needs to be reliable.</span></p><p class="c1"><span class="c0">&hellip; If your data payload grows over time, that may not be a big issue</span></p><p class="c1"><span class="c0">&hellip; When you reach the limit, you send immediately and then continue with fetch later</span></p><p class="c1"><span class="c0">&hellip; Also wanted to ask if there&rsquo;s a plan to redefined sendBeacon in terms of fetchLater</span></p><p class="c1"><span class="c0"><b>NoamR</b>: Unaware of such plans. It&rsquo;s an immediate fetch, but uses the keepalive quota (separate 64KB quota)</span></p><p class="c1"><span class="c0">Quota is per origin</span></p><p class="c1"><span class="c0"><b>Dan</b>: May be beneficial to have a guaranteed fallback mechanism, to enable some critical data to be sent over anything else</span></p><p class="c1"><span class="c0"><b>NoamR</b>: you can do that by sending a request with no body, with the data in the URL. If that becomes an abuse vector, we may need to do something about that</span></p><p class="c1"><span class="c0"><b>Fergal</b>: An alternative was to have some sort of a FIFO queue, so that pending requests are sent immediately when we run out of quota. Had its own drawbacks, where one provider can push another&rsquo;s beacons</span></p><h3 class="c11" id="h.ayzfxpw7gk89"><span>System load as a privacy preserving dimension</span></h3><p class="c1"><span class="c3"><a class="c5" href="https://www.google.com/url?q=https://youtu.be/hwaDS-KSxs0&amp;sa=D&amp;source=editors&amp;ust=1716320059381762&amp;usg=AOvVaw3WlkuCo64fd-heXJ59FF6O">Recording</a></span></p><p class="c1"><span><b>Slides</b>: </span><span class="c3"><a class="c5" href="https://www.google.com/url?q=https://docs.google.com/presentation/d/1DfTDA_VfOtYY9wLf8H8CEpN_Yedc_IySZGu2b3yRpj8/edit%23slide%3Did.g26dd20683a2_0_0&amp;sa=D&amp;source=editors&amp;ust=1716320059382431&amp;usg=AOvVaw1BwemkZoUHpJyuNBKv_ovE">Bimodal Performance Timings in WebApps April 2024 - Google Slides</a></span></p><p class="c1"><span class="c0"><b>Mike</b>: Want to allow developers to eliminate outlier metrics (local machine noise, high CPU, etc)</span></p><p class="c1"><span class="c0">&hellip; Called system entropy but no one liked the name</span></p><p class="c1"><span class="c0">&hellip; Needed to be exposed in a privacy preserving way</span></p><p class="c1"><span class="c0">&hellip; Ran an Origin Trial, collected data and applied differential privacy debiasing</span></p><p class="c1"><span>&hellip; </span><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 671.81px;<b> height</b>: 479.12px;"><img alt="" src="images/image3.png" style="width: 671.81px;<b> height</b>: 479.12px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&hellip; data with the randomized response significantly shifted the averages, but when debiasing the data, we got most of it back</span></p><p class="c1"><span>&hellip; </span><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 639.25px;<b> height</b>: 462.30px;"><img alt="" src="images/image2.png" style="width: 639.25px;<b> height</b>: 462.30px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&hellip; So feels like an avenue that&rsquo;s worth continuing to pursue. Allows RUM providers to collect that data in aggregate, but not useful for picking any particular session</span></p><p class="c1"><span class="c0">&hellip; Included the algorithm for debiasing in the slides</span></p><p class="c1"><span class="c0">&hellip; 2 questions for this group:</span></p><p class="c1"><span class="c0">&hellip; Given this data, is this worth pursuing? And assuming we do, we have 2 rough proposals.</span></p><p class="c1"><span>&hellip; </span><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 689.50px;<b> height</b>: 281.29px;"><img alt="" src="images/image4.png" style="width: 689.50px;<b> height</b>: 281.29px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&hellip; TODO</span></p><p class="c1"><span class="c0">&hellip; the downside is that the data as exposed is useless for developers</span></p><p class="c1"><span class="c0">&hellip; The second approach is plugging into the reporting end point API</span></p><p class="c1"><span class="c0">&hellip; Send the data to the reporting API, send this kind of payload</span></p><p class="c1"><span style="overflow: hidden;<b> display</b>: inline-block;<b> margin</b>: 0.00px 0.00px;<b> border</b>: 0.00px solid #000000;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);<b> width</b>: 687.96px;<b> height</b>: 499.46px;"><img alt="" src="images/image1.png" style="width: 687.96px;<b> height</b>: 499.46px; margin-left: 0.00px; margin-top: 0.00px;<b> transform</b>: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&hellip; some interesting opportunities there, TODO</span></p><p class="c1"><span class="c0">&hellip; That seems like roughly the approach that we want</span></p><p class="c1"><span><b>NoamR</b>: related to </span><span class="c3"><a class="c5" href="https://www.google.com/url?q=https://github.com/w3c/web-performance/wiki/Nice-things-we-can%2527t-have&amp;sa=D&amp;source=editors&amp;ust=1716320059384745&amp;usg=AOvVaw2vClfWZg6hClV70M3AnY8e">other things, e.g. battery level, memory, etc</a></span></p><p class="c1"><span>&hellip; Were looking at something that&rsquo;s more similar to your second direction - the </span><span class="c3"><a class="c5" href="https://www.google.com/url?q=https://github.com/patcg-individual-drafts/private-aggregation-api&amp;sa=D&amp;source=editors&amp;ust=1716320059385296&amp;usg=AOvVaw3w9hRZRqzl_8pyU1s3M5ld">private aggregation API</a></span></p><p class="c1"><span class="c0">&hellip; It&rsquo;s reporting, but the browser itself maintains the fuzzing and anonymizing</span></p><p class="c1"><span class="c0">&hellip; Ian and I started poking at this</span></p><p class="c1"><span class="c0">&hellip; If we could collaborate on this, that could be a direction for the bimodality you&rsquo;re seeing</span></p><p class="c1"><span class="c0"><b>Nic</b>: Was helpful to inform us. Interested as a RUM provider. Thinking about the 2 options, either in JS land or through reporting.</span></p><p class="c1"><span class="c0">&hellip; The benefit for us of getting this data in JS is that we can then associate that data with other dimensions we&rsquo;re getting</span></p><p class="c1"><span class="c0">&hellip; Reporting decouples that dimension from other dimensions that we currently have</span></p><p class="c1"><span class="c0">&hellip;Can bring it through JS, but not through reporting</span></p><p class="c1"><span class="c0">&hellip; That&rsquo;s why that information in JS could be useful</span></p><p class="c1"><span class="c0"><b>Mike</b>: The reporting API does have reporting observers, but it&rsquo;s not connected to NavTiming</span></p><p class="c1"><span class="c0"><b>Yoav</b>: Noam a lot of things on your list aren&rsquo;t dimensions but metrics, and we need to be careful to distinguishing the two</span></p><p class="c1"><span class="c0">&hellip; The reason Mike is interested in this data is not on its own, but in order to filter out other things. So it&rsquo;s a dimension rather than a metric.</span></p><p class="c1"><span class="c0">&hellip; Anonymously reporting metrics vs. dimensions require different solutions</span></p><p class="c1"><span class="c0">&hellip; I would like to get a better understanding why the information in JavaScript is not as useful as information to report</span></p><p class="c1"><span class="c0">&hellip; Not as useful on the machine in order to do stuff, as you don&rsquo;t want to make the wrong decision and change the user experience based on that randomized data</span></p><p class="c1"><span class="c0"><b>Mike</b>: My statement was around the first point, the JS developer can&rsquo;t take action in that moment to change the experience. &nbsp;And they can&rsquo;t even de-bias it locally. &nbsp;Unless they stored these for every session, can&rsquo;t de-bias locally.</span></p><p class="c1"><span class="c0">&hellip; So the only thing to do with this is bundle it up and send it off, aggregate it.</span></p><p class="c1"><span class="c0">&hellip; That&rsquo;s the bit that feels weird to me to hang of the object</span></p><p class="c1"><span class="c0"><b>Yoav</b>: Answers my question, but agree with Nic that usefulness is it can tie with other metrics on the client. &nbsp;If we report this regardless of those metrics, that would make it hard to use that data.</span></p><p class="c1"><span class="c0"><b>Noam</b>: What Yoav and Nic were saying were exactly the design decision with the Privacy Preserving API</span></p><p class="c1"><span class="c0"><b>Yoav</b>: Amazing!</span></p><p class="c1"><span class="c0"><b>Charlie</b>: To follow-up Yoav on exposing metrics vs. dimension, one reason why the local API has some benefits.</span></p><p class="c1"><span class="c0">&hellip; It will typically give noisier data vs. PA API</span></p><p class="c1"><span class="c0">&hellip; But gives you flexibility to do these splits online</span></p><p class="c1"><span class="c0">&hellip; Imagine you want to design a dashboard, and arbitrary splits on dashboard, on boolean or date or whatever</span></p><p class="c1"><span class="c0">&hellip; With this boolean, it&rsquo;s not &ldquo;easy&rdquo; to do that at query time, but doable</span></p><p class="c1"><span class="c0">&hellip; But with Private Agg API you need to setup those dimensions on the client</span></p><p class="c1"><span class="c0">&hellip; If you want a histogram of UA across the hour, you need to set that up on the page</span></p><p class="c1"><span class="c0">&hellip; So when we decide whether to use a local or central mechanism, that&rsquo;s a key factor we should think about</span></p><p class="c1"><span class="c0">&hellip; Central mechanism gives you much less noise, but cumbersome to use in the way I see this being used (dynamic histogram views exposed to customers)</span></p><p class="c1"><span class="c0">&hellip; </span></p><p class="c1"><span class="c0"><b>Noam</b>: This would be a design constraint in using Privacy Aggregation vs. this type</span></p><p class="c1"><span class="c0"><b>Yoav</b>: For some things, if we want to measure e.g. Total Page Weight, it&rsquo;s not a dimension, we can&rsquo;t use this mechanism for that, we need some sort of aggregation + server-side anonymization</span></p><p class="c1"><span class="c0">&hellip; But things where a dimension is what we&rsquo;re after, this pattern could be a good pattern to use</span></p><p class="c1"><span class="c0">&hellip; Mike also mentioned beyond just CPU load, you looked at decoupling those, was that part of experiments?</span></p><p class="c1"><span class="c0">&hellip; Not something we collected data on, just the implementation already in Chromium itself</span></p><p class="c1"><span class="c0">&hellip; Original proposal is everything coalesced into one value</span></p><p class="c1"><span class="c0">&hellip; If we wanted to e.g. calculate compute pressure at navigation time, that would be in there</span></p><p class="c1"><span class="c0">&hellip; Following randomization algo, we need to apply the right algo to ensure privacy levels are protected</span></p><p class="c1"><span class="c0"><b>Yoav</b>: Charlie in terms of the maths involved, how does this work for multiple dimensions?</span></p><p class="c1"><span class="c0">&hellip; e.g. discard measurements where any one of them were positive?</span></p><p class="c1"><span class="c0"><b>Charlie</b>: It&rsquo;s definitely possible, I think there&rsquo;s a decision the group will have to make on privacy front which will impact how doable this is</span></p><p class="c1"><span class="c0">&hellip; Are we privatizing all variables independently, or together as a batch?</span></p><p class="c1"><span class="c0">&hellip; Doable with two dimensions instead of one, but with 50+ dimensions it could be tough, algorithm starts breaking down after that many dimensions</span></p><p class="c1"><span class="c0">&hellip; I think we should not prematurely launching something without thinking though how this would work</span></p><p class="c1"><span class="c0">&hellip; You mentioned wanting a breakout if any of dimensions are true, in that case, put them all combined into a single boolean</span></p><p class="c1"><span class="c0">&hellip; We should also think about the use-case</span></p><p class="c1"><span class="c0">&hellip; Discard anything in case one of these booleans is true, we should coalesce</span></p><p class="c1"><span class="c0"><b>Noam</b>: In that list of nice things we can&rsquo;t have, for things that are a dimension, many of them are boolean</span></p><p class="c1"><span class="c0">... e.g. something happened outside of website&rsquo;s control that maybe the website should discard the measurements</span></p><p class="c1"><span class="c0">&hellip; e..g not high confidence</span></p><p class="c1"><span class="c0"><b>Mike</b>: One of the proposals I had discarded, confidence=high|low</span></p><p class="c1"><span class="c0"><b>Yoav</b>: Next steps?</span></p><p class="c1"><span class="c0">&hellip; Better understanding of use-cases beyond this boolean?</span></p><p class="c1"><span class="c0"><b>Mike</b>: I want to have a chance to read the other links, and I&rsquo;ll reach out to get a conversation started around what we do want to do or next-steps</span></p><p class="c1"><span class="c0">&hellip; Once we&rsquo;ve had that conversation, next step would be to update the explainer. &nbsp;Move to WICG once we&rsquo;ve coalesced around a proposal that we&rsquo;re happy with. &nbsp;Maybe get an update in Chromium once we decide what to do.</span></p><p class="c1"><span class="c0">Hearing that the reporting API is not the preferred approach - we&rsquo;d put that as an alternative considered.</span></p></body></html><script>
const resize = (tagName) => {
  let elements = document.getElementsByTagName(tagName);
  for (let elem of elements) {
    elem.style.height = "";
    elem.style.width = "800px";
  }
};
window.addEventListener('load', () => {
  resize("img");
  resize("span");
});
</script>
